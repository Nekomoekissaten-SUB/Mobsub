using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Mobsub.SubtitleParse.SourceGen;

[Generator]
public class AssPropertyGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new PropertySyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxContextReceiver is not PropertySyntaxReceiver receiver)
            return;

        foreach (var classSymbol in receiver.ClassSymbols)
        {
            GenerateModelCode(context, classSymbol);
        }
    }

    private void GenerateModelCode(GeneratorExecutionContext context, INamedTypeSymbol classSymbol)
    {
        bool isPartial = false;
        foreach (var declaration in classSymbol.DeclaringSyntaxReferences)
        {
            var syntax = declaration.GetSyntax() as ClassDeclarationSyntax;
            if (syntax?.Modifiers.Any(m => m.ValueText == "partial") == true)
            {
                isPartial = true;
                break;
            }
        }

        if (!isPartial)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    "ASG001",
                    "Class must be partial",
                    "Class '{0}' must be declared as partial to use property generation",
                    "AssPropertyGenerator",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                classSymbol.Name));
            return;
        }

        var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();
        var className = classSymbol.Name;
        var sourceBuilder = new StringBuilder();

        var modelAttribute = classSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass!.Name == "AssModelAttribute");

        bool generateBatchUpdate = true;
        bool autoPropertyGeneration = false;

        if (modelAttribute != null)
        {
            foreach (var arg in modelAttribute.NamedArguments)
            {
                if (arg.Key == "GenerateBatchUpdate" && arg.Value.Value is bool batchValue)
                    generateBatchUpdate = batchValue;
                else if (arg.Key == "AutoPropertyGeneration" && arg.Value.Value is bool autoValue)
                    autoPropertyGeneration = autoValue;
            }
        }

        var propertyFields = new List<IFieldSymbol>();
        var cachedPropertyFields = new List<IFieldSymbol>();

        foreach (var member in classSymbol.GetMembers().OfType<IFieldSymbol>())
        {
            if (member.GetAttributes().Any(a => a.AttributeClass!.Name == "AssPropertyAttribute"))
            {
                propertyFields.Add(member);
            }
            else if (member.GetAttributes().Any(a => a.AttributeClass!.Name == "AssCachedPropertyAttribute"))
            {
                cachedPropertyFields.Add(member);
            }
            else if (autoPropertyGeneration && member.Name.StartsWith("_") &&
                     member.DeclaredAccessibility == Accessibility.Private)
            {
                propertyFields.Add(member);
            }
        }

        sourceBuilder.AppendLine($@"// <auto-generated/>
#nullable enable
using System;
using System.Collections.Generic;

namespace {namespaceName}
{{
    partial class {className}
    {{
        public class PropertyChangedEventArgs : EventArgs
        {{
            public string PropertyName {{ get; }}
            public object? OldValue {{ get; }}
            public object? NewValue {{ get; }}
            
            public PropertyChangedEventArgs(string propertyName, object? oldValue, object? newValue)
            {{
                PropertyName = propertyName;
                OldValue = oldValue;
                NewValue = newValue;
            }}
        }}
        
        public event EventHandler<PropertyChangedEventArgs>? PropertyChanged;
");

        if (generateBatchUpdate)
        {
            sourceBuilder.AppendLine(@"
        private bool _batchUpdateMode = false;
        private readonly HashSet<string> _pendingNotifications = new HashSet<string>();
        
        public IDisposable BeginBatchUpdate()
        {
            _batchUpdateMode = true;
            return new BatchUpdateScope(this);
        }
        
        private void EndBatchUpdate()
        {
            _batchUpdateMode = false;
            
            // send all pending notifications
            if (_pendingNotifications.Count > 0 && PropertyChanged != null)
            {
                foreach (var property in _pendingNotifications)
                {
                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(property, null, null));
                }
                _pendingNotifications.Clear();
            }
        }
        
        private class BatchUpdateScope : IDisposable
        {
            private readonly " + className + @" _owner;
            
            public BatchUpdateScope(" + className + @" owner)
            {
                _owner = owner;
            }
            
            public void Dispose()
            {
                _owner.EndBatchUpdate();
            }
        }
        
        public void Update(Action<" + className + @"> updateAction)
        {
            using (BeginBatchUpdate())
            {
                updateAction(this);
            }
        }");
        }

        sourceBuilder.AppendLine(@"
        protected virtual void NotifyPropertyChanged(string propertyName, object? oldValue, object? newValue)
        {");

        if (generateBatchUpdate)
        {
            sourceBuilder.AppendLine(@"
            if (_batchUpdateMode)
            {
                _pendingNotifications.Add(propertyName);
                return;
            }");
        }

        sourceBuilder.AppendLine(@"
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName, oldValue, newValue));
        }");

        foreach (var field in propertyFields)
        {
            var fieldName = field.Name;
            var fieldType = field.Type.ToDisplayString();

            string propertyName;
            if (fieldName.StartsWith("_") && fieldName.Length > 1)
            {
                propertyName = char.ToUpper(fieldName[1]) + fieldName.Substring(2);
            }
            else
            {
                propertyName = fieldName;
            }

            var propAttribute = field.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass!.Name == "AssPropertyAttribute");

            var invalidatesProperties = new List<string>();

            if (propAttribute != null)
            {
                foreach (var arg in propAttribute.NamedArguments)
                {
                    if (arg.Key == "InvalidatesProperties" && arg.Value.Values.Length > 0)
                    {
                        invalidatesProperties.AddRange(
                            arg.Value.Values
                                .Select(v => v.Value?.ToString())
                                .Where(s => !string.IsNullOrEmpty(s))!);
                    }
                }
            }

            sourceBuilder.AppendLine(@"
        public " + fieldType + " " + propertyName + @"
        {
            get => " + fieldName + @";
            set
            {
                if (!EqualityComparer<" + fieldType + @">.Default.Equals(" + fieldName + @", value))
                {
                    var oldValue = " + fieldName + @";
                    " + fieldName + @" = value;
                    NotifyPropertyChanged(nameof(" + propertyName + @"), oldValue, value);");

            foreach (var invalidatesProp in invalidatesProperties)
            {
                sourceBuilder.AppendLine(@"
                    Invalidate" + invalidatesProp + @"();");
            }

            sourceBuilder.AppendLine(@"
                }
            }
        }");
        }

        foreach (var field in cachedPropertyFields)
        {
            var fieldName = field.Name;
            var fieldType = field.Type.ToDisplayString();

            string propertyName;
            if (fieldName.EndsWith("Cache"))
            {
                propertyName = fieldName.Substring(0, fieldName.Length - 5);
            }
            else if (fieldName.EndsWith("Cached"))
            {
                propertyName = fieldName.Substring(0, fieldName.Length - 6);
            }
            else
            {
                propertyName = fieldName + "Property";
            }

            var cacheAttribute = field.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass!.Name == "AssCachedPropertyAttribute");

            string validationFieldName = propertyName + "Valid";
            string calculationMethod = "Calculate" + propertyName;
            var dependsOnProperties = new List<string>();

            if (cacheAttribute != null)
            {
                foreach (var arg in cacheAttribute.NamedArguments)
                {
                    if (arg.Key == "CalculationMethod" && arg.Value.Value is string methodName)
                    {
                        calculationMethod = methodName;
                    }
                    else if (arg.Key == "DependsOn" && arg.Value.Values.Length > 0)
                    {
                        dependsOnProperties.AddRange(
                            arg.Value.Values
                                .Select(v => v.Value?.ToString())
                                .Where(s => !string.IsNullOrEmpty(s))!);
                    }
                }
            }

            sourceBuilder.AppendLine(@"
        private bool " + validationFieldName + @" = false;
        
        public void Invalidate" + propertyName + @"()
        {
            if (" + validationFieldName + @")
            {
                " + validationFieldName + @" = false;
                NotifyPropertyChanged(nameof(" + propertyName + @"), " + fieldName + @", null);
            }
        }
        
        public " + fieldType + @" " + propertyName + @"
        {
            get
            {
                if (!" + validationFieldName + @" || " + fieldName + @" == null)
                {
                    " + fieldName + @" = " + calculationMethod + @"();
                    " + validationFieldName + @" = true;
                }
                return " + fieldName + @";
            }
        }");
        }

        sourceBuilder.AppendLine(@"    }
}");

        context.AddSource($"{className}.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private class PropertySyntaxReceiver : ISyntaxContextReceiver
    {
        public List<INamedTypeSymbol> ClassSymbols { get; } = new List<INamedTypeSymbol>();

        public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
        {
            if (context.Node is ClassDeclarationSyntax classDeclaration)
            {
                var symbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
                if (symbol == null) return;

                if (symbol.GetAttributes().Any(a => a.AttributeClass!.Name == "AssModelAttribute") ||
                    symbol.GetMembers().OfType<IFieldSymbol>().Any(f =>
                        f.GetAttributes().Any(a =>
                            a.AttributeClass!.Name == "AssPropertyAttribute" ||
                            a.AttributeClass!.Name == "AssCachedPropertyAttribute")))
                {
                    ClassSymbols.Add(symbol);
                }
            }
        }
    }
}